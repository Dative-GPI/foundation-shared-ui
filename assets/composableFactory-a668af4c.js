import{a1 as i,d as o}from"./vue.esm-bundler-37de1696.js";function h(c,t=u=>!0,s=u=>u.id){return(e,r)=>{switch(e){case"add":y(c,r,s,t);return;case"update":g(c,r,s,t);return;case"delete":m(c,r,s);return}}}function f(c,t,s=u=>u.id){return(e,r)=>{if(!c.value)return;const n=s(c.value);(e==="add"||e==="update")&&n===s(r)&&(c.value=r,t&&t(r)),e==="delete"&&n===r&&(c.value=null)}}function y(c,t,s,u){const e=c.value,r=s(t),n=e.findIndex(l=>s(l)===r),a=u(t);n==-1&&a?e.push(t):n==-1&&!a||(n!=-1&&!a?e.splice(n,1):e.splice(n,1,t))}function g(c,t,s,u){const e=c.value,r=s(t),n=e.findIndex(l=>s(l)===r),a=u(t);n!=-1&&a?e.splice(n,1,t):n!=-1&&!a?e.splice(n,1):n==-1&&a&&e.push(t)}function m(c,t,s){const u=c.value,e=u.findIndex(r=>s(r)===t);e!=-1&&u.splice(e,1)}class v{static create(t){return u=>{for(const e in t)if(u[e]!==t[e])return!1;return!0}}}class M{static get(t,s){return()=>{const u=s?s():()=>{};let e=[];i(()=>{e.forEach(l=>t.unsubscribe(l)),e=[]});const r=o(!1),n=o(null);return{getting:r,get:async l=>{r.value=!0;try{n.value=await t.get(l),u&&u(n.value)}finally{r.value=!1}return e.push(t.subscribe("all",f(n,u))),n},entity:n}}}static getMany(t,s){return()=>{const u=s?s():()=>{};let e=[];i(()=>{e.forEach(l=>t.unsubscribe(l)),e=[]});const r=o(!1),n=o([]);return{fetching:r,getMany:async(l,d)=>{r.value=!0;try{if(n.value=await t.getMany(l),u)for(const b of n.value)u(b)}finally{r.value=!1}const p=d||(l?v.create(l):b=>!0);return e.push(t.subscribe("all",h(n,p))),n},entities:n}}}static custom(t,s){return()=>{const u=s?s():()=>{},e=o(!1),r=o(null);return{fetching:e,fetch:async(...a)=>{e.value=!0;try{r.value=await t(...a),u&&u(r)}finally{e.value=!1}return r},entity:r}}}static sync(t){return()=>{let s=[];const u=o([]);return i(()=>{s.forEach(r=>t.unsubscribe(r)),s=[]}),{synceds:u,sync:(r,n,a)=>{u.value=r;const l=a||(n?v.create(n):d=>!0);return s.push(t.subscribe("all",h(u,l))),u}}}}static track(t){return()=>{let s=[];return i(()=>{s.forEach(e=>t.unsubscribe(e)),s=[]}),{track:(e,r,n=!0)=>(s.push(t.subscribe("all",f(e,r))),r&&n&&r(e.value),e)}}}static create(t){return()=>{let s=[];i(()=>{s.forEach(n=>t.unsubscribe(n)),s=[]});const u=o(!1),e=o(null);return{creating:u,create:async n=>{u.value=!0;try{e.value=await t.create(n)}finally{u.value=!1}return s.push(t.subscribe("all",f(e))),e},created:e}}}static update(t){return()=>{let s=[];i(()=>{s.forEach(n=>t.unsubscribe(n)),s=[]});const u=o(!1),e=o(null);return{updating:u,update:async(n,a)=>{u.value=!0;try{e.value=await t.update(n,a)}finally{u.value=!1}return s.push(t.subscribe("all",f(e))),e.value},updated:e}}}static remove(t){return()=>{const s=o(!1);return{removing:s,remove:async e=>{s.value=!0;try{await t.remove(e)}finally{s.value=!1}}}}}}export{M as C};
