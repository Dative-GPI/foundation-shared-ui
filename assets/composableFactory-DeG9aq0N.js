import{V as i,b as o}from"./vue.esm-bundler-BLBBrD1D.js";function d(l,t=r=>!0,s=r=>r.id){return(e,u)=>{switch(e){case"add":v(l,u,s,t);return;case"update":y(l,u,s,t);return;case"delete":g(l,u,s);return}}}function f(l,t,s=r=>r.id){return(e,u)=>{if(!l.value)return;const n=s(l.value);(e==="add"||e==="update")&&n===s(u)&&(l.value=u,t&&t(l)),e==="delete"&&n===u&&(l.value=null)}}function v(l,t,s,r){const e=l.value,u=s(t),n=e.findIndex(c=>s(c)===u),a=r(t);n==-1&&a?e.push(t):n==-1&&!a||(n!=-1&&!a?e.splice(n,1):e.splice(n,1,t))}function y(l,t,s,r){const e=l.value,u=s(t),n=e.findIndex(c=>s(c)===u),a=r(t);n!=-1&&a?e.splice(n,1,t):n!=-1&&!a?e.splice(n,1):n==-1&&a&&e.push(t)}function g(l,t,s){const r=l.value,e=r.findIndex(u=>s(u)===t);e!=-1&&r.splice(e,1)}class h{static create(t){return r=>{for(const e in t)if(r[e]!==t[e])return!1;return!0}}}class E{static get(t,s){return()=>{const r=s?s():()=>{};let e=[];i(()=>{e.forEach(c=>t.unsubscribe(c)),e=[]});const u=o(!1),n=o(null);return{getting:u,get:async c=>{u.value=!0;try{n.value=await t.get(c),r&&r(n)}finally{u.value=!1}return e.push(t.subscribe("all",f(n,r))),n},entity:n}}}static getMany(t,s){return()=>{const r=s?s():()=>{};let e=[];i(()=>{e.forEach(c=>t.unsubscribe(c)),e=[]});const u=o(!1),n=o([]);return{fetching:u,getMany:async(c,b)=>{u.value=!0;try{n.value=await t.getMany(c),r&&r(n)}finally{u.value=!1}const p=b||(c?h.create(c):I=>!0);return e.push(t.subscribe("all",d(n,p))),n},entities:n}}}static custom(t,s){return()=>{const r=s?s():()=>{},e=o(!1),u=o(null);return{fetching:e,fetch:async(...a)=>{e.value=!0;try{u.value=await t(...a),r&&r(u)}finally{e.value=!1}return u},entity:u}}}static sync(t){return()=>{let s=[];return i(()=>{s.forEach(e=>t.unsubscribe(e)),s=[]}),{sync:(e,u,n)=>{const a=o(e),c=n||(u?h.create(u):b=>!0);return s.push(t.subscribe("all",d(a,c))),a}}}}static syncRef(t){return()=>{let s=[];return i(()=>{s.forEach(e=>t.unsubscribe(e)),s=[]}),{sync:(e,u,n)=>{const a=n||(u?h.create(u):c=>!0);return s.push(t.subscribe("all",d(e,a))),e}}}}static track(t){return()=>{let s=[];return i(()=>{s.forEach(e=>t.unsubscribe(e)),s=[]}),{track:(e,u)=>{const n=o(e);return s.push(t.subscribe("all",f(n,a=>u?u(a.value):null))),n}}}}static trackRef(t){return()=>{let s=[];return i(()=>{s.forEach(e=>t.unsubscribe(e)),s=[]}),{track:(e,u)=>(s.push(t.subscribe("all",f(e,u))),e)}}}static create(t,s){return()=>{const r=s?s():()=>{};let e=[];i(()=>{e.forEach(c=>t.unsubscribe(c)),e=[]});const u=o(!1),n=o(null);return{creating:u,create:async c=>{u.value=!0;try{n.value=await t.create(c),r&&r(n)}finally{u.value=!1}return e.push(t.subscribe("all",f(n))),n},created:n}}}static update(t,s){return()=>{const r=s?s():()=>{};let e=[];i(()=>{e.forEach(c=>t.unsubscribe(c)),e=[]});const u=o(!1),n=o(null);return{updating:u,update:async(c,b)=>{u.value=!0;try{n.value=await t.update(c,b),r&&r(n)}finally{u.value=!1}return e.push(t.subscribe("all",f(n))),n.value},updated:n}}}static remove(t){return()=>{const s=o(!1);return{removing:s,remove:async e=>{s.value=!0;try{await t.remove(e)}finally{s.value=!1}}}}}}export{E as C};
